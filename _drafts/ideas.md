---
layout: post
category : ideas
title: ideas
tagline: "ideas"
tags : [ideas]
article_img: bootstrap/img/qn.png
---
{% include JB/setup %}








-----------------------------------

 * google weather prediction insurance spin out company
 * article (finite state machines as software design) <- search email for that subject


 * economics of software quality
 * Redundant Heterogeneous EventBus (Rhebus).

http://stackoverflow.com/questions/3987391/why-people-use-message-event-buses-in-their-code

http://code.google.com/p/mvp4g/wiki/EventBus
http://code.google.com/p/simpleeventbus/

could I build a bus using https://github.com/LMAX-Exchange/disruptor ?

 * tracing program flow in event driven / reactive programs
 * software snobbery and open source (read: free software)
audacity is like the bottom and X is like the most expensive and is better and Y is like in between.

note: opinion based on price.

 * IoT actual real numbers and implementations
 https://www.google.com.au/search?client=ubuntu&channel=fs&q=internet+of+things+real+actual+deployments&ie=utf-8&oe=utf-8&gfe_rd=cr&ei=6l_tVNDXJayN8QeGu4GgBQ
http://postscapes.com/internet-of-things-examples/
http://en.wikipedia.org/wiki/Intelligent_street_lighting
https://www.google.com.au/search?client=ubuntu&channel=fs&q=smart+street+lighting&ie=utf-8&oe=utf-8&gfe_rd=cr&ei=0mDtVNmkBKyN8QeGu4GgBQ#safe=off&channel=fs&q=smart+street+lighting+copenhagen
how IoT will help self driving cars?

"future" section for blog? 

 * the Quantified Self
tracking personal data and stuff...

http://trendwatching.com/trends/currencies-of-change/


 * P vs NP: The future of humanity will be defined by cracking NP. Look at existing NP problems in manufacturing, logistics, bio/medical research, etc and implications of fixing those
 * timesheeting of developers
 * "hackathons"
 * why your code is shit (paying low, short contracts, timesheets, no long term career paths, churn, lack of care, apathy, no users, no one cares.)

 * future trends in programming: looking towards the future, maths concepts and functional programming, moving into parallel programming and concurrency. Future libraries will need to be concurrent. Evolution will be Explicit -> implicit, languages like java need to bake parallelism into core libs. 

 


 * API design. (little manual of API design)
 
 https://mandrillapp.com/api/docs/
 
 * Knuth: programming is writing. Even books and articles on complex subjects are fairly light on structure.

‘The programmer, has to be able to think in terms of conceptual hierarchies that are much deeper than a single mind ever needed to face before.’

 * reactor pattern, event loops, etc. ala twisted 
 
 * serendipity - discovering patterns and methodologies by chance (i.e. after coding them, find out later those patterns exist)
 
 * performance enhancing drugs (software engineering)
 
 
 
 * The myth of the just world
don't be naive, be politically savvy. "the myth of the just world"
http://www.manager-tools.com/2013/04/politics-101-chapter-3-myth-just-world-part-1
http://www.manager-tools.com/2013/05/politics-101-chapter-3-myth-just-world-part-2
 
you wont be rewarded accordingly, all success includes political calculations (personal). 
just world hypothesis.
i will be rewarded appropriately if I work hard and get ahead by doing so. cognitive dissonance.

confirmation bias.
play the game. unfair, no strict rules.
learn when to be selfish.

case based pattern matching in scala (map, collect, match)
 