---
layout: post
title: "Asleep at the Wheel"
description: "Asleep at the Wheel"
tagline: "craft"
category: craft
tags: [craft, design, craftsmanship, compsci, programming, coding]
article_img: bootstrap/img/Sleeping-Hamster.jpg
article_img_title: Asleep at the Wheel by Unknown
---
{% include JB/setup %}
<div class="intro">
<div class="intro-txt">
<span markdown="span">
**Hamster Wheel**
</span>

/ˈhæm.stər wiːl/ 

<p>
<span markdown="span">_A monotonous, repetitive, unfulfilling activity, especially one in which no progress is achieved.[^1]_</span>
</p>

<p>
<span markdown="span">[Like other rodents, hamsters are highly motivated to run in wheels][1].</span> Likewise, programmers in the early stages of their careers are highly motivated to run in wheels too. Digging into as many languages, libraries and frameworks they can get their hands on, building stuff using whatever happens to be popular this month and working insane hours either on the job, or at home after work and on weekends until stupid o'clock.
</p>

<p>
As time goes on, it appears more developers are concerned about their future in the industry if they don't run that hamster wheel full-speed and play, build or learn each new technology that comes along for fear of being left behind. This lifestyle is not sustainable, not healthy and certainly not the way to hone ones craft.
</p>

</div>
<div class="intro-img-border">
<div class="intro-img-bevel">
<div class="intro-img">
<img class="article-image" title="{{page.article_img_title}}" src="{{ASSET_PATH}}/{{page.article_img}}"/>
</div>
</div>
</div>
</div>
<br/>
<br/>

#### Experience 
The knowledge or skill acquired by a period of practical experience of something, especially that gained in a particular profession

If there is one thing experience teaches a developer, it is that you _will_ burn out. Possibly many times. The older one gets, the less motivation and capacity one has to stay up late every evening burning the midnight oil. Devoting ones life to the pursuit of learning yet another short lived framework or niche language to the exclusion of other physically, emotionally or mentally stimulating activities that aren't programming is the fast track to unhappiness and burn out. Spend your weekends doing other fulfilling activities that, no matter what they are, tangentially broaden your mind and expand your knowledge and experience as a human being. Doing this is bound to improve your skills as a developer in ways that cannot be predicted. Software is for humans, not computers. With more experience, one can reliably determine whether something is worth incorporating into their work or not. Unless and until _new X_ is set to dramatically improve ones work, unless it provides performance gains, simplicity, or some other measurale benefit, there is no reason to invest. When the time does come to invest in a new language, framework, library, pattern or methodology however, you will be able to learn enough in a week or two when required.
<br/>
<br/>


#### expertise
expert skill or knowledge in a particular field.

#### Skills
the ability to do something well.


#### Familiarity
Close acquaintance with or knowledge of something

#### Knowledge = Experience + Skills + Familiarity
awareness or familiarity gained by experience of a fact or situation.
Facts, information, and skills acquired through experience or education; the theoretical or practical understanding of a subject.






Its a bit like cooking - the cookbooks for the peasants give recipes. The ones for the chefs give mechanics and techniques.
So learn pointers, functional programming, asynchronous operations and few more important paradigms, learn how to keep a code base tidy and organized and just ignore the foam on the water that is the hot new tech. 

Constantly. If there's one lesson I could hope to impart to any budding developer, it's to never stop building. Learn a bit about genetic algorithms - then implement a simple one. Learn a little Ruby, then build something with it. This will teach you a lot of what you need to know - fill in the gaps with Google. Focus on building good abstractions, and you'll be fine wherever you go.



Learn paradigms and principles. If you know what to do, you will be able to find the tools to do it.
Focus on theory and putting it into practice by building stuff. Build
Read up on various design patterns. read up on architecture and methodologies. Realize that no-architecture is frequently chosen due to ignorance ('pragmatism'). Learn OOP, FP, logic, prototype and rule based programming principles. Learn parallel programming, learn concurrency, [learn synchronous vs asynchronous invocation and message passing patterns]({% post_url 2014-05-02-invocation-matters %}). Learn how to decouple functionality, learn single responsibility principles, learn open/closed principles, learn DRY (don't repeat yourself), also learn the tradeoffs, costs, benefits and efficiencies of these things. Learn when and when not to use frameworks and libraries. Don't just blindly use framework when you could possibly roll your own solution with minimal code resulting in a far simpler system (this is particularly important when using only 1% of the functionality of that library).

Dependency Injection frameworks, Javascript application frameworks, DOM manipulation libraries, SQL providers and frameworks, NoSQL solutions, OO languages, FP languages, concurrent and parallel languages and frameworks, to name but a few tricial examples from the top of ones head. Not sustainable. 

You can practice these concepts every day, and you should, if only to develop the necessary element of taste.
You'll go through a phase where you adhere to these ideas religiously, then eventually assimilate the knowledge so that it becomes almost unconscious.


Another new presentation layer javascript framework? What's the benefit? MVC? Great, learn MVC as a design pattern instead.





as you gain more experience, (which can correlate to the older you get, especially when you start early), you get better at knowing when something will really improve your work (making it faster, better looking, more enjoyable, better performing, more efficient, etc.) and when it won't. Perhaps the article's author is actually on to something. He intuitively knows New Tool X won't improve his work much, and he's wiser than his younger self, who would waste time chasing non-essential niceties.











I had pretty much the same experience when learning functional programming. However, I don't think it was functional programming per se that caused a jump in my ability to design  software. It was the exposure to a dual perspective.

The difference is subtle but important. You need to master imperative programming for the exposure to functional to produce a  evolution. You can probably get the same effect in the reverse path (functional first, imperative next) but it's quite uncommon as a learning path.
The same reasoning leads me to advise exposure to logic languages (prolog and the like), to compiler design (a complex state machine) and to a complete algebraic abstraction (relational algebra is probably the best candidate). Each will bring into your toolbox an important top level tool, no matter which paradigm you use at any moment in your life.


Note that a lot (most?) comp sci programs don't necessarily address design principles. If you're in a software engineering track they should, but my curriculum was mostly algorithms, data structures, operating systems, and programming languages. My senior year I had one class where design and project management was really a topic.



So read books, build things and read code.


#### Signal to noise ratio


#### so what to do?
wow, didn't realise I bashed out so much stuff to learn... anyway, you have the rest of your career to do so and each problem you tackle will guide you on what to learn next. The point being, focussing on theory, design principles and patterns, programming fundamentals and implementing them in real systems will teach you much more than learning every new language, library or framework that comes along. [Read blogs, articles, code and books]({% post_url 2014-06-25-code-incomplete %}), and write code and always be building things. From my experience, early career programmers tend to spend as much time as possible coding, however, as programmers mature they tend to spend less time coding and more time reading and thinking. Early career programmers need to take some time out of their coding each day for reading and thinking. Don't feel as though you are being employed to type code all day, because this is patently false (even if it does make you feel guilty for not doing so). You are a knowledge worker, you are being paid for your powers of deduction, logic and abstraction all of which require constant refinement. You _will_ write better code in a shorter period of time by spending less time coding and more time reading and thinking.







<br/>
<br/>



 
 
 
 
 
#### Simplicity

I've certainly noticed a shift in that these hard learnt lessons are being ignored in order to add features to frameworks etc; which increase their applicable scope, with the increase in complexity that arises. The primary driver of which appears to be the younger generations desire to use the same tools for different purposes rather than learn a new set of applicable tools for a different problem domain. A good example is the shift from v1 Zend Framework to Zend Framework 2 which just appears to be so heavily "Java/Enterprise" influenced I simply refuse to use it; its far far too complex a framework for what is essentially a framework for building web sites. Building web sites is simple. These modern frameworks make it massively more complex than it needs to be.

Which is why simplicity remains the ultimate sophistication in software architectures. At some point, you cannot continue writing code without structure. Then you slowly and deliberately introduce meaningful abstractions along the necessary dimensions.
And no more.
Abstractions are also useful to separate the arrangement of work from the actual work itself. These boundaries are useful for dividing up work among colleagues.

Knuth argues that programming is a form of writing. I agree. Therefore, you should organize code like a book or article, since those are forms of writing that have benefitted from centuries of use and refinement.
Even books and articles on complex subjects are fairly light on structure.


Unless for need, interest or fun, do not learn like-for-like frameworks and languages in a vain effort to keep up. Instead learn to abstract and/or generalise the relevent benefits and technologies behind the latest hipster languages and frameworks and the evangelists patterns and methodologies. 
Only learn what languages and frameworks _you_ want and need to learn and apply your deeper knowledge within those. 


#### Asleep at the Wheel
Experience forces developers to work smarter, not harder.
Learn theory and technique, gain a deeper and fundamental knowledge. Get off the hamster wheel.



[1]:http://en.wikipedia.org/wiki/Hamster_wheel
[2]:http://en.wiktionary.org/wiki/hamster_wheel


#### Notes
[^1]:[http://en.wiktionary.org/wiki/hamster_wheel][2]