---
layout: post
title: "Asleep at the Wheel"
description: "Asleep at the Wheel"
tagline: "craft"
category: craft
tags: [craft, design, craftsmanship, compsci, programming, coding]
article_img: bootstrap/img/Sleeping-Hamster.jpg
article_img_title: Asleep at the Wheel by Unknown
---
{% include JB/setup %}
<div class="intro">
<div class="intro-txt">
<span markdown="span">
**Hamster Wheel**
</span>

/ˈhæm.stər wiːl/ 

<p>
<span markdown="span">_A monotonous, repetitive, unfulfilling activity, especially one in which no progress is achieved.[^1]_</span>
</p>

<p>
<span markdown="span">[Like other rodents, hamsters are highly motivated to run in wheels][1].</span> Likewise, programmers in the early stages of their careers are highly motivated to run in wheels too. Aside from their paid work, they'll dig deep into as many languages, libraries and frameworks they can get their hands on, building stuff using whatever happens to be popular this month and working insane hours either on the job, or at home after work and on weekends until stupid o'clock.
</p>

<p>
As time goes on, it appears more developers are concerned about their future in the industry if they don't run that hamster wheel full-speed and play, build or learn each new technology that comes along for fear of being left behind. This lifestyle is not sustainable, not healthy and certainly not the way to hone ones craft.
</p>

</div>
<div class="intro-img-border">
<div class="intro-img-bevel">
<div class="intro-img">
<img class="article-image" title="{{page.article_img_title}}" src="{{ASSET_PATH}}/{{page.article_img}}"/>
</div>
</div>
</div>
</div>
<br/>
<br/>

#### Burnout 
If there is one thing experience teaches you as a developer, it is that you _will_ burn out. Possibly many times. Devoting your life to the pursuit of learning yet another short lived framework or niche language to the exclusion of other physically, emotionally and mentally stimulating activities that aren't programming is the fast track to unhappiness and burn out. You'll be asleep at the wheel. It's unavoidable that the older you get, the less motivation and capacity you will have to stay up late every evening burning the midnight oil.
<br/>
<br/>







#### Limited Time, Unlimited Scope
build good abstractions
Read up on various design patterns. read up on architecture and methodologies.

Learn Object Oriented Programming, Functional Programming, logic, prototype and rule based programming principles. Learn static and dymanic type systems. Learn parallel programming, learn concurrency, [learn synchronous vs asynchronous invocation and message passing patterns]({% post_url 2014-05-02-invocation-matters %}). Learn how to decouple functionality, learn single responsibility principles, learn open/closed principles, learn DRY (don't repeat yourself), learn how to abstract and generalise concepts, also learn the tradeoffs, costs, benefits and efficiencies of these things. Learn how to organise your code base and use version control. Learn how to test and debug. Learn when and when not to use frameworks and libraries. Don't just blindly use a framework when you could possibly roll your own solution with minimal code as this will result in a far simpler system. With the web at your disposal you can learn anything but _not everything_.

learn to recognise anti-patterns and code smells
If you know what to do, you will be able to find the tools to do it.

state machines
AI and machine learning topics.
geospatial stuff.

backbone, node, angular, ember, etc.
if you're a web dev, build some desktop or server apps and vice verca.

generalise rather than specialise.


function composition
composition over inheritance


share what you know, help others.

oop and fp: It was the exposure to a dual perspective.


All of these things add incredible bredth and flexibility to your reportoire covering most programming and design situations you're likely to encounter, no matter the language or library, and if not, you'll have the background knowledge to tackle it.










 
 
 
 
#### Simplicity
In many codebases and systems I've seen over the years there has been an overwhelming amount of complexity added by developers using the mindset of stitching together numerous frameworks and libraries for only small pieces of functionality. Do you really need an ORM for a simple application with a handful of database queries? Building websites can be pretty simple, many MVC frameworks and the like actually make this job harder. Simplicity has been forgotten. Only introduce structure, generalisation and abstractions as you design, build and recognise the need. Use modularisation to divvy up work if you're working in a team.
_Simplicity is the ultimate sophistication_ -- <cite>[Unknown][3]</cite>.
<br/>
<br/>

#### Experience
With experience, you'll be able to reliably determine whether something is worth incorporating into your work or not. Unless and until _new thing X_ is set to dramatically improve your work, unless it provides performance gains, simplicity, or some other measurable benefit, there is no reason to invest unless for pure interest. When the time does come to invest in a new language, framework, library, pattern or methodology however, you will be able to learn enough in a week or two when required.
<br/>
<br/>

#### Is that it?
Wow, didn't realise I'd bashed out so much stuff to learn! Anyway, you have the rest of your career to learn and each problem you tackle will guide you on what to learn next. The point being, focussing on theory, design principles and patterns, programming fundamentals and implementing them in real systems will teach you much more than learning every new language, library or framework that comes along. Read blogs, articles, code and books (and don't restrict this reading to programming!), [review your previous work]({% post_url 2014-06-25-code-incomplete %}) and always be building things. 

Early in your career you'll most likely tend to spend as much time as possible coding, however, as you mature you need to spend less time coding and more time reading and thinking. Early career programmers need to take some time out of their coding each day for reading and thinking. Don't feel as though you are being employed to type code all day, because this is patently untrue. You're a knowledge worker, you're being paid for your powers of deduction, logic and abstraction, you're being paid for your ability to build complex systems from abstract concepts using nothing but your mind. You _will_ write better code in a shorter period of time by spending less time coding and more time reading and thinking.

Spend your weekends doing other fulfilling activities which, no matter what they are, tangentially broaden your mind and expand your knowledge and experience as a human being. This is bound to improve your skills as a programmer and present serendipitous opportunities in ways that cannot be predicted. 

Unless for need, interest or fun, do not learn like-for-like frameworks and languages in a vain effort to keep up. Instead learn to abstract and generalise the relevent benefits and technologies behind them, and if need be, learn those concepts. Only learn what languages and frameworks _you_ want and need to learn and apply your deeper knowledge within those.

Along your journey you will develop your own style and taste. You'll develop the instincts to know when and how to break the rules. Your knowledge will become so ingrained that execution of such concepts becomes second nature. The journey is that of continual learning, working smarter not harder, and it is a journey you should enjoy. Learn theory and technique, gain a deeper and fundamental knowledge and forget about every new language, framework or library that comes along. Get off the hamster wheel.
<br/>
<br/>



 













[1]:http://en.wikipedia.org/wiki/Hamster_wheel
[2]:http://en.wiktionary.org/wiki/hamster_wheel
[3]:http://en.wikipedia.org/wiki/Simplicity


#### Notes
[^1]:[http://en.wiktionary.org/wiki/hamster_wheel][2]